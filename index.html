<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralGenesis - Neural Network IDE</title>
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.5.1/dist/tfjs-vis.umd.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        cyan: '#00f2ff',
                        amber: '#ffbf00',
                        'pitch-black': '#050505',
                        'industrial-gray': '#1a1a1a',
                        'glass': 'rgba(255, 255, 255, 0.05)',
                    },
                    backdropBlur: {
                        'glass': '12px',
                    },
                    animation: {
                        'neuron-pulse': 'neuronPulse 1.5s ease-in-out infinite',
                        'gradient-flow': 'gradientFlow 3s ease-in-out infinite',
                        'fade-in': 'fadeIn 0.5s ease-out',
                        'slide-in': 'slideIn 0.3s ease-out',
                    },
                    keyframes: {
                        neuronPulse: {
                            '0%, 100%': { opacity: 0.3, transform: 'scale(1)' },
                            '50%': { opacity: 1, transform: 'scale(1.1)' },
                        },
                        gradientFlow: {
                            '0%, 100%': { backgroundPosition: '0% 50%' },
                            '50%': { backgroundPosition: '100% 50%' },
                        },
                        fadeIn: {
                            '0%': { opacity: 0 },
                            '100%': { opacity: 1 },
                        },
                        slideIn: {
                            '0%': { transform: 'translateY(10px)', opacity: 0 },
                            '100%': { transform: 'translateY(0)', opacity: 1 },
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom CSS for glassmorphism and animations */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            background: #050505;
            color: #ffffff;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow-x: hidden;
        }
        
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .neuron-svg {
            filter: drop-shadow(0 0 8px rgba(0, 242, 255, 0.5));
        }
        
        .weight-slider::-webkit-slider-thumb {
            background: #00f2ff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .weight-slider::-moz-range-thumb {
            background: #00f2ff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .tri-pane {
                flex-direction: column;
            }
            
            .mobile-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                z-index: 100;
                background: #050505;
            }
        }
        
        /* Performance optimizations */
        .performance-mode * {
            animation: none !important;
            transition: none !important;
        }
        
        /* Custom scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #00f2ff;
            border-radius: 3px;
        }
    </style>
</head>
<body class="min-h-screen bg-pitch-black text-white">
    <!-- Performance Mode Toggle -->
    <div class="fixed top-4 right-4 z-50">
        <button id="performanceToggle" class="glass px-3 py-1 rounded-lg text-xs flex items-center gap-2 hover:bg-opacity-30 transition-all">
            <i data-lucide="battery"></i>
            <span>Performance Mode</span>
        </button>
    </div>

    <!-- Desktop Header -->
    <header class="glass p-4 border-b border-white/10">
        <div class="container mx-auto">
            <div class="flex justify-between items-center">
                <div class="flex items-center gap-4">
                    <h1 class="text-2xl font-bold bg-gradient-to-r from-cyan to-amber bg-clip-text text-transparent">
                        <i data-lucide="brain" class="inline mr-2"></i>NeuralGenesis
                    </h1>
                    <span class="text-xs px-2 py-1 rounded bg-cyan/20 text-cyan">v2.0</span>
                </div>
                
                <div class="flex items-center gap-6">
                    <!-- Status Indicators -->
                    <div class="flex items-center gap-4">
                        <div id="webgpuStatus" class="flex items-center gap-2">
                            <div class="w-2 h-2 rounded-full bg-red-500"></div>
                            <span class="text-sm">WebGPU: Off</span>
                        </div>
                        <div id="memoryStatus" class="flex items-center gap-2">
                            <i data-lucide="memory-stick" class="w-4 h-4"></i>
                            <span class="text-sm">Memory: --</span>
                        </div>
                        <div id="epochCounter" class="flex items-center gap-2">
                            <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                            <span class="text-sm">Epoch: 0</span>
                        </div>
                    </div>
                    
                    <!-- Model Controls -->
                    <div class="flex gap-2">
                        <button id="trainBtn" class="px-4 py-2 bg-cyan text-black rounded-lg font-semibold hover:bg-cyan/80 transition-colors">
                            <i data-lucide="play" class="w-4 h-4 inline mr-2"></i>Train
                        </button>
                        <button id="pauseBtn" class="px-4 py-2 glass rounded-lg hover:bg-white/10 transition-colors">
                            <i data-lucide="pause" class="w-4 h-4 inline mr-2"></i>Pause
                        </button>
                        <button id="exportBtn" class="px-4 py-2 glass rounded-lg hover:bg-white/10 transition-colors">
                            <i data-lucide="download" class="w-4 h-4 inline mr-2"></i>Export
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Mobile Navigation -->
    <nav class="md:hidden glass fixed bottom-0 left-0 right-0 p-4 z-40">
        <div class="flex justify-around">
            <button data-modal="architecture" class="flex flex-col items-center gap-1">
                <i data-lucide="layers"></i>
                <span class="text-xs">Architecture</span>
            </button>
            <button data-modal="training" class="flex flex-col items-center gap-1">
                <i data-lucide="activity"></i>
                <span class="text-xs">Training</span>
            </button>
            <button data-modal="console" class="flex flex-col items-center gap-1">
                <i data-lucide="terminal"></i>
                <span class="text-xs">Console</span>
            </button>
            <button data-modal="weights" class="flex flex-col items-center gap-1">
                <i data-lucide="sliders"></i>
                <span class="text-xs">Weights</span>
            </button>
        </div>
    </nav>

    <!-- Main Content - Tri-Pane Layout -->
    <main class="container mx-auto p-4">
        <div class="tri-pane flex gap-4 min-h-[75vh]">
            <!-- Panel A: The Forge -->
            <div class="flex-1 glass rounded-xl p-4">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold flex items-center gap-2">
                        <i data-lucide="hammer" class="text-cyan"></i>
                        The Forge
                    </h2>
                    <button id="clearDataset" class="text-xs glass px-2 py-1 rounded hover:bg-white/10">
                        Clear Dataset
                    </button>
                </div>
                
                <!-- Dataset Uploader -->
                <div class="mb-6">
                    <div class="border-2 border-dashed border-white/20 rounded-lg p-6 text-center mb-4 hover:border-cyan/50 transition-colors">
                        <input type="file" id="datasetUpload" accept=".csv,.json,.txt" class="hidden">
                        <label for="datasetUpload" class="cursor-pointer">
                            <i data-lucide="upload" class="w-12 h-12 mx-auto mb-2 text-white/50"></i>
                            <p class="text-sm">Drop CSV/JSON dataset or click to upload</p>
                            <p class="text-xs text-white/50 mt-1">Supports CSV, JSON, and image datasets</p>
                        </label>
                    </div>
                    
                    <div id="datasetInfo" class="hidden glass p-3 rounded-lg">
                        <div class="flex justify-between items-center mb-2">
                            <span class="font-medium">Dataset Loaded</span>
                            <span id="datasetSize" class="text-xs text-cyan">0 samples</span>
                        </div>
                        <div id="datasetSchema" class="text-xs space-y-1"></div>
                    </div>
                </div>
                
                <!-- Feature Selection -->
                <div id="featureSelection" class="hidden mb-6">
                    <h3 class="font-medium mb-2">Feature Selection</h3>
                    <div id="featureCheckboxes" class="space-y-2 max-h-40 overflow-y-auto custom-scrollbar p-2"></div>
                    <div class="mt-3">
                        <label class="text-sm">Label Column:</label>
                        <select id="labelSelect" class="w-full glass p-2 rounded mt-1"></select>
                    </div>
                </div>
                
                <!-- Layer Builder -->
                <div class="mb-4">
                    <h3 class="font-medium mb-3">Neural Architecture</h3>
                    <div id="layerList" class="space-y-3 mb-4 max-h-60 overflow-y-auto custom-scrollbar p-2">
                        <!-- Layers will be added here -->
                    </div>
                    
                    <div class="flex gap-2">
                        <select id="layerType" class="flex-1 glass p-2 rounded">
                            <option value="dense">Dense Layer</option>
                            <option value="dropout">Dropout Layer</option>
                            <option value="lstm">LSTM Layer</option>
                            <option value="conv2d">Conv2D Layer</option>
                        </select>
                        <button id="addLayer" class="glass px-4 py-2 rounded hover:bg-white/10">
                            <i data-lucide="plus"></i>
                        </button>
                    </div>
                    
                    <div id="layerParams" class="mt-3 space-y-3 hidden">
                        <!-- Dynamic layer parameters -->
                    </div>
                </div>
                
                <!-- Training Parameters -->
                <div>
                    <h3 class="font-medium mb-3">Training Configuration</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="text-xs">Epochs</label>
                            <input type="number" id="epochs" value="50" min="1" class="w-full glass p-2 rounded">
                        </div>
                        <div>
                            <label class="text-xs">Batch Size</label>
                            <input type="number" id="batchSize" value="32" min="1" class="w-full glass p-2 rounded">
                        </div>
                        <div>
                            <label class="text-xs">Learning Rate</label>
                            <input type="number" id="learningRate" value="0.001" step="0.0001" class="w-full glass p-2 rounded">
                        </div>
                        <div>
                            <label class="text-xs">Validation Split</label>
                            <input type="number" id="validationSplit" value="0.2" step="0.05" min="0" max="0.5" class="w-full glass p-2 rounded">
                        </div>
                    </div>
                    
                    <div class="mt-3">
                        <label class="text-xs">Optimizer</label>
                        <select id="optimizer" class="w-full glass p-2 rounded mt-1">
                            <option value="adam">Adam</option>
                            <option value="sgd">SGD</option>
                            <option value="rmsprop">RMSprop</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Panel B: The Visualizer -->
            <div class="flex-1 glass rounded-xl p-4">
                <h2 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <i data-lucide="eye" class="text-cyan"></i>
                    The Visualizer
                </h2>
                
                <!-- Real-time Metrics -->
                <div id="tfjsVisContainer" class="h-48 mb-4">
                    <div class="h-full flex items-center justify-center text-white/50">
                        Training metrics will appear here
                    </div>
                </div>
                
                <!-- Neural Network Visualization -->
                <div class="relative h-64 glass rounded-lg overflow-hidden">
                    <svg id="neuralVisualization" class="w-full h-full neuron-svg">
                        <!-- SVG neurons and connections will be rendered here -->
                    </svg>
                    <div class="absolute bottom-2 right-2 text-xs flex gap-2">
                        <button id="resetView" class="glass px-2 py-1 rounded">Reset View</button>
                        <button id="toggleAnimations" class="glass px-2 py-1 rounded">Pulse Off</button>
                    </div>
                </div>
                
                <!-- Inference Chat -->
                <div class="mt-4">
                    <h3 class="font-medium mb-2">Inference Chat</h3>
                    <div class="glass rounded-lg p-3">
                        <div id="chatOutput" class="h-24 overflow-y-auto custom-scrollbar mb-2 text-sm space-y-1"></div>
                        <div class="flex gap-2">
                            <input type="text" id="chatInput" placeholder="Type to test inference..." 
                                   class="flex-1 glass p-2 rounded text-sm" disabled>
                            <button id="sendChat" class="glass px-3 rounded hover:bg-white/10" disabled>
                                <i data-lucide="send"></i>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Confidence Bar -->
                    <div class="mt-2">
                        <div class="flex justify-between text-xs mb-1">
                            <span>Inference Confidence</span>
                            <span id="confidenceValue">0%</span>
                        </div>
                        <div class="w-full bg-white/10 rounded-full h-2">
                            <div id="confidenceBar" class="bg-gradient-to-r from-cyan to-amber h-2 rounded-full w-0"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Panel C: The Weight Hacker -->
            <div class="flex-1 glass rounded-xl p-4">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold flex items-center gap-2">
                        <i data-lucide="code-2" class="text-cyan"></i>
                        The Weight Hacker
                    </h2>
                    <div class="text-xs flex items-center gap-2">
                        <span>Live Edit:</span>
                        <div id="liveEditStatus" class="w-2 h-2 rounded-full bg-red-500"></div>
                    </div>
                </div>
                
                <!-- Weight Controls -->
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm">Weight Manipulation</span>
                        <button id="randomizeWeights" class="text-xs glass px-2 py-1 rounded hover:bg-white/10">
                            Randomize All
                        </button>
                    </div>
                    
                    <div id="weightControls" class="space-y-4 max-h-96 overflow-y-auto custom-scrollbar p-2">
                        <!-- Dynamic weight sliders will be added here -->
                        <div class="text-center text-white/50 p-4">
                            Train a model first to see weight controls
                        </div>
                    </div>
                </div>
                
                <!-- Tensor Inspector -->
                <div>
                    <h3 class="font-medium mb-2">Tensor Inspector</h3>
                    <div class="glass rounded-lg p-3">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm">Selected Tensor:</span>
                            <span id="selectedTensor" class="text-xs text-cyan">None</span>
                        </div>
                        <div class="text-xs space-y-1">
                            <div class="flex justify-between">
                                <span>Shape:</span>
                                <span id="tensorShape">--</span>
                            </div>
                            <div class="flex justify-between">
                                <span>Data Type:</span>
                                <span id="tensorType">--</span>
                            </div>
                            <div class="flex justify-between">
                                <span>Mean Value:</span>
                                <span id="tensorMean">--</span>
                            </div>
                        </div>
                        <div class="mt-3">
                            <textarea id="tensorData" 
                                      class="w-full glass p-2 rounded text-xs font-mono h-20" 
                                      readonly
                                      placeholder="Tensor data will appear here..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Terminal Footer -->
    <footer class="glass border-t border-white/10 p-4">
        <div class="container mx-auto">
            <div class="flex items-center justify-between mb-2">
                <div class="flex items-center gap-4">
                    <h3 class="font-medium flex items-center gap-2">
                        <i data-lucide="terminal" class="text-amber"></i>
                        Neural Terminal
                    </h3>
                    <div class="flex gap-2">
                        <button id="clearTerminal" class="text-xs glass px-2 py-1 rounded hover:bg-white/10">
                            Clear
                        </button>
                        <button id="pauseLogging" class="text-xs glass px-2 py-1 rounded hover:bg-white/10">
                            Pause Logging
                        </button>
                    </div>
                </div>
                <div class="text-xs flex items-center gap-4">
                    <span id="tfVersion">TensorFlow.js v4.10.0</span>
                    <span id="memoryUsage">Memory: 0MB</span>
                </div>
            </div>
            
            <div id="terminalOutput" class="h-32 overflow-y-auto custom-scrollbar font-mono text-sm bg-black/50 rounded-lg p-3 space-y-1">
                <div class="text-cyan">[System] NeuralGenesis initialized</div>
                <div class="text-white/70">[Info] Waiting for dataset upload...</div>
            </div>
        </div>
    </footer>

    <!-- Mobile Modals -->
    <div id="mobileArchitectureModal" class="mobile-modal hidden">
        <!-- Mobile version of Panel A -->
    </div>
    
    <div id="mobileTrainingModal" class="mobile-modal hidden">
        <!-- Mobile version of Panel B -->
    </div>
    
    <div id="mobileConsoleModal" class="mobile-modal hidden">
        <!-- Mobile version of Terminal -->
    </div>

    <!-- JavaScript Application -->
    <script>
        // NeuralGenesis Application
        class NeuralGenesis {
            constructor() {
                this.model = null;
                this.training = false;
                this.paused = false;
                this.dataset = null;
                this.normalizationParams = {};
                this.layers = [];
                this.weights = [];
                this.logging = true;
                this.performanceMode = false;
                this.trainingHistory = {
                    loss: [],
                    accuracy: [],
                    val_loss: [],
                    val_accuracy: []
                };
                
                this.init();
            }
            
            async init() {
                // Initialize Lucide icons
                lucide.createIcons();
                
                // Check WebGPU support
                this.checkWebGPU();
                
                // Initialize IndexedDB
                await this.initIndexedDB();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Load saved model if exists
                await this.loadSavedModel();
                
                // Start memory monitoring
                this.startMemoryMonitoring();
                
                this.log('[System] NeuralGenesis initialized successfully');
            }
            
            // ============ INITIALIZATION ============
            
            checkWebGPU() {
                const gpuEl = document.getElementById('webgpuStatus');
                if (navigator.gpu) {
                    gpuEl.innerHTML = '<div class="w-2 h-2 rounded-full bg-green-500"></div><span class="text-sm">WebGPU: Ready</span>';
                    this.log('[System] WebGPU acceleration available');
                } else {
                    this.log('[System] WebGPU not available, using CPU fallback');
                }
            }
            
            async initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('NeuralGenesisDB', 1);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('models')) {
                            db.createObjectStore('models', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('datasets')) {
                            db.createObjectStore('datasets', { keyPath: 'id' });
                        }
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        this.log('[System] IndexedDB initialized');
                        resolve();
                    };
                    
                    request.onerror = () => {
                        this.log('[Error] Failed to initialize IndexedDB', 'error');
                        reject();
                    };
                });
            }
            
            startMemoryMonitoring() {
                setInterval(() => {
                    const memoryInfo = performance.memory;
                    if (memoryInfo) {
                        const usedMB = Math.round(memoryInfo.usedJSHeapSize / 1048576);
                        const totalMB = Math.round(memoryInfo.totalJSHeapSize / 1048576);
                        document.getElementById('memoryUsage').textContent = `Memory: ${usedMB}MB/${totalMB}MB`;
                        document.getElementById('memoryStatus').innerHTML = 
                            `<i data-lucide="memory-stick" class="w-4 h-4"></i><span class="text-sm">${usedMB}MB</span>`;
                        
                        // Warning if memory usage is high
                        if (usedMB > totalMB * 0.8) {
                            this.log('[Warning] High memory usage detected', 'warning');
                        }
                    }
                }, 2000);
            }
            
            // ============ DATASET HANDLING ============
            
            handleDatasetUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const content = e.target.result;
                    const extension = file.name.split('.').pop().toLowerCase();
                    
                    try {
                        if (extension === 'csv') {
                            this.parseCSV(content);
                        } else if (extension === 'json') {
                            this.parseJSON(content);
                        } else {
                            this.log('[Error] Unsupported file format', 'error');
                        }
                    } catch (error) {
                        this.log(`[Error] Failed to parse dataset: ${error.message}`, 'error');
                    }
                };
                
                reader.readAsText(file);
            }
            
            parseCSV(content) {
                const lines = content.split('\n');
                const headers = lines[0].split(',').map(h => h.trim());
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const values = lines[i].split(',').map(v => v.trim());
                        if (values.length === headers.length) {
                            const row = {};
                            headers.forEach((header, index) => {
                                const numValue = parseFloat(values[index]);
                                row[header] = isNaN(numValue) ? values[index] : numValue;
                            });
                            data.push(row);
                        }
                    }
                }
                
                this.dataset = data;
                this.normalizeDataset();
                this.updateDatasetUI(headers);
                this.log(`[Dataset] Loaded ${data.length} samples with ${headers.length} features`);
            }
            
            parseJSON(content) {
                const data = JSON.parse(content);
                
                if (Array.isArray(data)) {
                    this.dataset = data;
                    const headers = Object.keys(data[0] || {});
                    this.normalizeDataset();
                    this.updateDatasetUI(headers);
                    this.log(`[Dataset] Loaded ${data.length} samples from JSON`);
                } else {
                    throw new Error('JSON must be an array of objects');
                }
            }
            
            normalizeDataset() {
                if (!this.dataset || this.dataset.length === 0) return;
                
                const headers = Object.keys(this.dataset[0]);
                this.normalizationParams = {};
                
                headers.forEach(header => {
                    const values = this.dataset.map(row => row[header]).filter(v => typeof v === 'number');
                    
                    if (values.length > 0) {
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        
                        if (max !== min) {
                            this.normalizationParams[header] = { min, max, range: max - min };
                            
                            // Apply min-max normalization
                            this.dataset.forEach(row => {
                                if (typeof row[header] === 'number') {
                                    row[`${header}_normalized`] = (row[header] - min) / (max - min);
                                }
                            });
                        }
                    }
                });
            }
            
            updateDatasetUI(headers) {
                const datasetInfo = document.getElementById('datasetInfo');
                const featureSelection = document.getElementById('featureSelection');
                const featureCheckboxes = document.getElementById('featureCheckboxes');
                const labelSelect = document.getElementById('labelSelect');
                
                datasetInfo.classList.remove('hidden');
                featureSelection.classList.remove('hidden');
                
                document.getElementById('datasetSize').textContent = `${this.dataset.length} samples`;
                
                // Update schema display
                const schemaDiv = document.getElementById('datasetSchema');
                schemaDiv.innerHTML = headers.map(header => 
                    `<div class="flex justify-between">
                        <span>${header}</span>
                        <span class="text-cyan">${typeof this.dataset[0][header]}</span>
                    </div>`
                ).join('');
                
                // Update feature checkboxes
                featureCheckboxes.innerHTML = headers.map(header => 
                    `<label class="flex items-center gap-2">
                        <input type="checkbox" checked data-feature="${header}" class="rounded">
                        <span class="text-sm">${header}</span>
                    </label>`
                ).join('');
                
                // Update label select
                labelSelect.innerHTML = '<option value="">Select label column</option>' +
                    headers.map(header => `<option value="${header}">${header}</option>`).join('');
                
                // Enable chat input
                document.getElementById('chatInput').disabled = false;
                document.getElementById('sendChat').disabled = false;
            }
            
            // ============ MODEL ARCHITECTURE ============
            
            addLayer(type) {
                const layerId = `layer_${Date.now()}`;
                const layer = {
                    id: layerId,
                    type: type,
                    params: this.getDefaultLayerParams(type)
                };
                
                this.layers.push(layer);
                this.renderLayer(layer);
                this.updateLayerParamsUI(type);
                
                this.log(`[Architecture] Added ${type} layer`);
            }
            
            getDefaultLayerParams(type) {
                switch(type) {
                    case 'dense':
                        return { units: 32, activation: 'relu' };
                    case 'dropout':
                        return { rate: 0.5 };
                    case 'lstm':
                        return { units: 32, returnSequences: false };
                    case 'conv2d':
                        return { filters: 32, kernelSize: [3, 3], activation: 'relu' };
                    default:
                        return {};
                }
            }
            
            renderLayer(layer) {
                const layerList = document.getElementById('layerList');
                const layerDiv = document.createElement('div');
                layerDiv.className = 'glass p-3 rounded-lg flex items-center justify-between';
                layerDiv.id = layer.id;
                
                layerDiv.innerHTML = `
                    <div>
                        <div class="font-medium">${layer.type}</div>
                        <div class="text-xs text-white/70">${JSON.stringify(layer.params)}</div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="app.editLayer('${layer.id}')" class="p-1 hover:bg-white/10 rounded">
                            <i data-lucide="edit-2" class="w-4 h-4"></i>
                        </button>
                        <button onclick="app.removeLayer('${layer.id}')" class="p-1 hover:bg-white/10 rounded">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </div>
                `;
                
                layerList.appendChild(layerDiv);
                lucide.createIcons();
            }
            
            updateLayerParamsUI(type) {
                const paramsDiv = document.getElementById('layerParams');
                paramsDiv.classList.remove('hidden');
                
                let paramsHTML = '';
                
                switch(type) {
                    case 'dense':
                        paramsHTML = `
                            <div>
                                <label class="text-xs">Units</label>
                                <input type="number" id="denseUnits" value="32" class="w-full glass p-2 rounded">
                            </div>
                            <div>
                                <label class="text-xs">Activation</label>
                                <select id="denseActivation" class="w-full glass p-2 rounded">
                                    <option value="relu">ReLU</option>
                                    <option value="sigmoid">Sigmoid</option>
                                    <option value="tanh">Tanh</option>
                                    <option value="softmax">Softmax</option>
                                </select>
                            </div>
                        `;
                        break;
                    case 'dropout':
                        paramsHTML = `
                            <div>
                                <label class="text-xs">Dropout Rate</label>
                                <input type="number" id="dropoutRate" value="0.5" step="0.1" min="0" max="1" class="w-full glass p-2 rounded">
                            </div>
                        `;
                        break;
                }
                
                paramsDiv.innerHTML = paramsHTML;
            }
            
            removeLayer(layerId) {
                this.layers = this.layers.filter(l => l.id !== layerId);
                document.getElementById(layerId)?.remove();
                this.log(`[Architecture] Removed layer ${layerId}`);
            }
            
            createModel() {
                if (this.layers.length === 0) {
                    this.log('[Error] No layers added to model', 'error');
                    return null;
                }
                
                const model = tf.sequential();
                
                this.layers.forEach(layer => {
                    switch(layer.type) {
                        case 'dense':
                            model.add(tf.layers.dense({
                                units: layer.params.units || 32,
                                activation: layer.params.activation || 'relu',
                                inputShape: layer === this.layers[0] ? [this.getInputShape()] : undefined
                            }));
                            break;
                        case 'dropout':
                            model.add(tf.layers.dropout({
                                rate: layer.params.rate || 0.5
                            }));
                            break;
                        case 'lstm':
                            model.add(tf.layers.lstm({
                                units: layer.params.units || 32,
                                returnSequences: layer.params.returnSequences || false
                            }));
                            break;
                    }
                });
                
                // Add output layer
                model.add(tf.layers.dense({
                    units: this.getOutputUnits(),
                    activation: 'softmax'
                }));
                
                const optimizer = document.getElementById('optimizer').value;
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                
                let tfOptimizer;
                switch(optimizer) {
                    case 'adam':
                        tfOptimizer = tf.train.adam(learningRate);
                        break;
                    case 'sgd':
                        tfOptimizer = tf.train.sgd(learningRate);
                        break;
                    case 'rmsprop':
                        tfOptimizer = tf.train.rmsprop(learningRate);
                        break;
                }
                
                model.compile({
                    optimizer: tfOptimizer,
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                
                this.model = model;
                this.log('[Model] Neural network created successfully');
                
                return model;
            }
            
            getInputShape() {
                if (!this.dataset) return 1;
                
                const featureCheckboxes = document.querySelectorAll('input[data-feature]:checked');
                return featureCheckboxes.length;
            }
            
            getOutputUnits() {
                if (!this.dataset) return 1;
                
                const labelColumn = document.getElementById('labelSelect').value;
                if (!labelColumn) return 1;
                
                const uniqueLabels = [...new Set(this.dataset.map(row => row[labelColumn]))];
                return uniqueLabels.length;
            }
            
            // ============ TRAINING ============
            
            async train() {
                if (!this.dataset) {
                    this.log('[Error] No dataset loaded', 'error');
                    return;
                }
                
                if (!this.model) {
                    this.createModel();
                    if (!this.model) return;
                }
                
                this.training = true;
                this.paused = false;
                
                const epochs = parseInt(document.getElementById('epochs').value);
                const batchSize = parseInt(document.getElementById('batchSize').value);
                const validationSplit = parseFloat(document.getElementById('validationSplit').value);
                
                // Prepare data
                const { inputs, labels } = this.prepareTrainingData();
                
                // Setup callbacks
                const callbacks = {
                    onEpochEnd: async (epoch, logs) => {
                        if (this.paused) {
                            this.model.stopTraining = true;
                            return;
                        }
                        
                        document.getElementById('epochCounter').innerHTML = 
                            `<i data-lucide="refresh-cw" class="w-4 h-4"></i><span class="text-sm">Epoch: ${epoch + 1}</span>`;
                        
                        // Update training history
                        this.trainingHistory.loss.push(logs.loss);
                        this.trainingHistory.accuracy.push(logs.acc);
                        this.trainingHistory.val_loss.push(logs.val_loss);
                        this.trainingHistory.val_accuracy.push(logs.val_acc);
                        
                        // Update visualizations
                        this.updateTrainingCharts();
                        this.updateNeuralVisualization();
                        
                        // Update weight controls
                        this.updateWeightControls();
                        
                        // Log progress
                        this.log(`[Training] Epoch ${epoch + 1} - Loss: ${logs.loss.toFixed(4)}, Acc: ${(logs.acc * 100).toFixed(2)}%`);
                        
                        // Save model periodically
                        if ((epoch + 1) % 10 === 0) {
                            await this.saveModel();
                        }
                    },
                    onBatchEnd: (batch, logs) => {
                        // Update terminal with gradient info
                        if (this.logging && batch % 10 === 0) {
                            this.log(`[Batch ${batch}] Loss: ${logs.loss.toFixed(4)}`, 'gradient');
                        }
                    }
                };
                
                // Start training
                this.log(`[Training] Starting training for ${epochs} epochs...`);
                
                try {
                    const history = await this.model.fit(inputs, labels, {
                        epochs: epochs,
                        batchSize: batchSize,
                        validationSplit: validationSplit,
                        callbacks: callbacks,
                        verbose: 0
                    });
                    
                    this.log('[Training] Training completed successfully');
                    this.updateWeightControls();
                    
                } catch (error) {
                    this.log(`[Error] Training failed: ${error.message}`, 'error');
                } finally {
                    this.training = false;
                    inputs.dispose();
                    labels.dispose();
                }
            }
            
            prepareTrainingData() {
                const featureCheckboxes = document.querySelectorAll('input[data-feature]:checked');
                const labelColumn = document.getElementById('labelSelect').value;
                
                const featureIndices = Array.from(featureCheckboxes).map(cb => cb.getAttribute('data-feature'));
                
                // Extract features and labels
                const features = this.dataset.map(row => 
                    featureIndices.map(feature => row[`${feature}_normalized`] || row[feature] || 0)
                );
                
                const labels = this.dataset.map(row => row[labelColumn]);
                const uniqueLabels = [...new Set(labels)];
                const labelMap = Object.fromEntries(uniqueLabels.map((l, i) => [l, i]));
                
                // Convert to one-hot encoding
                const oneHotLabels = labels.map(label => {
                    const arr = new Array(uniqueLabels.length).fill(0);
                    arr[labelMap[label]] = 1;
                    return arr;
                });
                
                // Convert to tensors
                const inputTensor = tf.tensor2d(features);
                const labelTensor = tf.tensor2d(oneHotLabels);
                
                return { inputs: inputTensor, labels: labelTensor };
            }
            
            // ============ WEIGHT MANIPULATION ============
            
            updateWeightControls() {
                if (!this.model) return;
                
                const weightControls = document.getElementById('weightControls');
                weightControls.innerHTML = '';
                
                let weightIndex = 0;
                this.model.layers.forEach((layer, layerIndex) => {
                    const weights = layer.getWeights();
                    
                    weights.forEach((weightTensor, tensorIndex) => {
                        const weightId = `weight_${layerIndex}_${tensorIndex}`;
                        const weightData = weightTensor.dataSync();
                        
                        // Create weight control for each weight value
                        weightData.forEach((value, index) => {
                            const controlDiv = document.createElement('div');
                            controlDiv.className = 'space-y-1';
                            
                            controlDiv.innerHTML = `
                                <div class="flex justify-between text-xs">
                                    <span>W${weightIndex}[${index}]</span>
                                    <span class="text-cyan">${value.toFixed(4)}</span>
                                </div>
                                <div class="flex gap-2">
                                    <input type="range" min="-2" max="2" step="0.01" value="${value}"
                                           class="weight-slider flex-1" 
                                           data-layer="${layerIndex}"
                                           data-tensor="${tensorIndex}"
                                           data-index="${index}"
                                           oninput="app.updateWeightValue(this)">
                                    <input type="number" min="-2" max="2" step="0.01" value="${value}"
                                           class="w-20 glass p-1 rounded text-center"
                                           data-layer="${layerIndex}"
                                           data-tensor="${tensorIndex}"
                                           data-index="${index}"
                                           onchange="app.updateWeightValue(this)">
                                </div>
                            `;
                            
                            weightControls.appendChild(controlDiv);
                            weightIndex++;
                        });
                    });
                });
                
                this.log(`[Weights] Updated ${weightIndex} weight controls`);
            }
            
            updateWeightValue(element) {
                if (!this.model || !this.training) return;
                
                const layerIndex = parseInt(element.getAttribute('data-layer'));
                const tensorIndex = parseInt(element.getAttribute('data-tensor'));
                const weightIndex = parseInt(element.getAttribute('data-index'));
                const newValue = parseFloat(element.value);
                
                // Update the other control
                const controls = document.querySelectorAll(
                    `[data-layer="${layerIndex}"][data-tensor="${tensorIndex}"][data-index="${weightIndex}"]`
                );
                
                controls.forEach(control => {
                    if (control !== element) {
                        control.value = newValue;
                    }
                });
                
                // Update the actual tensor
                const layer = this.model.layers[layerIndex];
                const weights = layer.getWeights();
                const weightTensor = weights[tensorIndex];
                
                const newValues = Array.from(weightTensor.dataSync());
                newValues[weightIndex] = newValue;
                
                const newTensor = tf.tensor(newValues, weightTensor.shape);
                const newWeights = [...weights];
                newWeights[tensorIndex] = newTensor;
                
                layer.setWeights(newWeights);
                
                // Update visualizations
                this.updateNeuralVisualization();
                
                // Update live edit status
                document.getElementById('liveEditStatus').className = 'w-2 h-2 rounded-full bg-green-500';
                setTimeout(() => {
                    document.getElementById('liveEditStatus').className = 'w-2 h-2 rounded-full bg-red-500';
                }, 1000);
            }
            
            randomizeWeights() {
                if (!this.model) return;
                
                this.model.layers.forEach(layer => {
                    const weights = layer.getWeights();
                    const newWeights = weights.map(weightTensor => {
                        const shape = weightTensor.shape;
                        const newValues = Array.from({ length: weightTensor.size }, 
                            () => (Math.random() * 4 - 2)); // Random values between -2 and 2
                        return tf.tensor(newValues, shape);
                    });
                    layer.setWeights(newWeights);
                });
                
                this.updateWeightControls();
                this.log('[Weights] All weights randomized');
            }
            
            // ============ INFERENCE & CHAT ============
            
            async runInference(text) {
                if (!this.model || !this.dataset) {
                    this.log('[Error] Model not trained or dataset not loaded', 'error');
                    return null;
                }
                
                try {
                    // Simple tokenization based on dataset vocabulary
                    const featureCheckboxes = document.querySelectorAll('input[data-feature]:checked');
                    const features = Array.from(featureCheckboxes).map(cb => cb.getAttribute('data-feature'));
                    
                    // Create input based on text (simplified)
                    const inputArray = features.map(feature => {
                        const textLower = text.toLowerCase();
                        const featureLower = feature.toLowerCase();
                        
                        // Check if feature name appears in text
                        if (textLower.includes(featureLower)) {
                            return 1.0;
                        }
                        
                        // Simple character-based encoding
                        let score = 0;
                        for (let char of textLower) {
                            if (featureLower.includes(char)) {
                                score += 0.1;
                            }
                        }
                        
                        return Math.min(score, 1.0);
                    });
                    
                    // Normalize input
                    const normalizedInput = inputArray.map((val, index) => {
                        const feature = features[index];
                        const params = this.normalizationParams[feature];
                        if (params) {
                            return (val - params.min) / params.range;
                        }
                        return val;
                    });
                    
                    // Create tensor and run prediction
                    const inputTensor = tf.tensor2d([normalizedInput]);
                    const prediction = this.model.predict(inputTensor);
                    const results = await prediction.data();
                    
                    // Clean up
                    inputTensor.dispose();
                    prediction.dispose();
                    
                    // Find highest confidence
                    const maxConfidence = Math.max(...results);
                    const predictedClass = results.indexOf(maxConfidence);
                    
                    // Update UI
                    this.updateConfidenceBar(maxConfidence);
                    
                    return {
                        confidence: maxConfidence,
                        class: predictedClass,
                        allResults: results
                    };
                    
                } catch (error) {
                    this.log(`[Error] Inference failed: ${error.message}`, 'error');
                    return null;
                }
            }
            
            updateConfidenceBar(confidence) {
                const percent = Math.round(confidence * 100);
                document.getElementById('confidenceValue').textContent = `${percent}%`;
                document.getElementById('confidenceBar').style.width = `${percent}%`;
            }
            
            // ============ VISUALIZATIONS ============
            
            updateTrainingCharts() {
                const metrics = ['loss', 'accuracy'];
                const container = document.getElementById('tfjsVisContainer');
                
                container.innerHTML = '';
                
                metrics.forEach(metric => {
                    const surface = { name: metric, tab: 'Training' };
                    const data = {
                        values: this.trainingHistory[metric].map((val, i) => ({ x: i, y: val })),
                        series: ['Training']
                    };
                    
                    if (this.trainingHistory[`val_${metric}`].length > 0) {
                        data.values.push(
                            this.trainingHistory[`val_${metric}`].map((val, i) => ({ x: i, y: val }))
                        );
                        data.series.push('Validation');
                    }
                    
                    tfvis.render.linechart(surface, data, {
                        xLabel: 'Epoch',
                        yLabel: metric,
                        width: container.clientWidth,
                        height: 100
                    });
                });
            }
            
            updateNeuralVisualization() {
                const svg = document.getElementById('neuralVisualization');
                svg.innerHTML = '';
                
                if (!this.model) return;
                
                const width = svg.clientWidth;
                const height = svg.clientHeight;
                
                // Draw neural network visualization
                const layers = this.model.layers;
                const layerCount = layers.length;
                
                // Calculate positions
                const neuronRadius = 10;
                const layerSpacing = width / (layerCount + 1);
                
                // Draw connections and neurons
                for (let i = 0; i < layerCount; i++) {
                    const layer = layers[i];
                    const weights = layer.getWeights();
                    const x = (i + 1) * layerSpacing;
                    
                    if (weights.length > 0) {
                        const weightTensor = weights[0];
                        const neuronCount = weightTensor.shape[0];
                        const prevNeuronCount = i > 0 ? layers[i-1].getWeights()[0].shape[0] : 0;
                        
                        const neuronSpacing = height / (neuronCount + 1);
                        
                        // Draw neurons
                        for (let j = 0; j < neuronCount; j++) {
                            const y = (j + 1) * neuronSpacing;
                            
                            // Draw connections from previous layer
                            if (i > 0 && prevNeuronCount > 0) {
                                const prevX = i * layerSpacing;
                                const prevSpacing = height / (prevNeuronCount + 1);
                                
                                for (let k = 0; k < prevNeuronCount; k++) {
                                    const prevY = (k + 1) * prevSpacing;
                                    
                                    // Get weight value for connection
                                    const weightData = weightTensor.dataSync();
                                    const weightValue = weightData[k * neuronCount + j] || 0;
                                    
                                    // Calculate color based on weight
                                    const opacity = Math.abs(weightValue) * 0.5;
                                    const color = weightValue >= 0 ? '#00f2ff' : '#ffbf00';
                                    
                                    // Draw connection
                                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                    line.setAttribute('x1', prevX.toString());
                                    line.setAttribute('y1', prevY.toString());
                                    line.setAttribute('x2', x.toString());
                                    line.setAttribute('y2', y.toString());
                                    line.setAttribute('stroke', color);
                                    line.setAttribute('stroke-opacity', opacity.toString());
                                    line.setAttribute('stroke-width', '1');
                                    svg.appendChild(line);
                                }
                            }
                            
                            // Draw neuron
                            const neuron = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            neuron.setAttribute('cx', x.toString());
                            neuron.setAttribute('cy', y.toString());
                            neuron.setAttribute('r', neuronRadius.toString());
                            neuron.setAttribute('fill', '#00f2ff');
                            neuron.setAttribute('opacity', '0.7');
                            neuron.setAttribute('class', 'animate-neuron-pulse');
                            svg.appendChild(neuron);
                        }
                    }
                }
            }
            
            // ============ PERSISTENCE ============
            
            async saveModel() {
                if (!this.model) return;
                
                try {
                    // Save model to IndexedDB
                    const modelJSON = this.model.toJSON();
                    const weightData = await this.model.getWeights();
                    
                    const modelData = {
                        id: 'current_model',
                        modelJSON: modelJSON,
                        layers: this.layers,
                        datasetInfo: {
                            size: this.dataset?.length || 0,
                            features: Object.keys(this.normalizationParams)
                        },
                        timestamp: Date.now()
                    };
                    
                    const transaction = this.db.transaction(['models'], 'readwrite');
                    const store = transaction.objectStore('models');
                    await store.put(modelData);
                    
                    // Save weights separately
                    weightData.forEach((weight, index) => {
                        localStorage.setItem(`model_weight_${index}`, JSON.stringify(Array.from(weight.dataSync())));
                        localStorage.setItem(`model_weight_shape_${index}`, JSON.stringify(weight.shape));
                    });
                    
                    this.log('[Persistence] Model saved to IndexedDB');
                    
                } catch (error) {
                    this.log(`[Error] Failed to save model: ${error.message}`, 'error');
                }
            }
            
            async loadSavedModel() {
                try {
                    const transaction = this.db.transaction(['models'], 'readonly');
                    const store = transaction.objectStore('models');
                    const request = store.get('current_model');
                    
                    request.onsuccess = async () => {
                        if (request.result) {
                            const modelData = request.result;
                            
                            // Restore layers
                            this.layers = modelData.layers || [];
                            
                            // Recreate and render layers
                            this.layers.forEach(layer => this.renderLayer(layer));
                            
                            this.log('[Persistence] Loaded saved model architecture');
                        }
                    };
                    
                } catch (error) {
                    this.log(`[Error] Failed to load saved model: ${error.message}`, 'error');
                }
            }
            
            async exportModel() {
                if (!this.model) {
                    this.log('[Error] No model to export', 'error');
                    return;
                }
                
                try {
                    // Get model topology and weights
                    const modelJSON = this.model.toJSON();
                    const weightData = await this.model.getWeights();
                    
                    // Convert weights to arrays
                    const weightArrays = weightData.map(weight => Array.from(weight.dataSync()));
                    const weightShapes = weightData.map(weight => weight.shape);
                    
                    // Create export object
                    const exportData = {
                        modelTopology: modelJSON,
                        weightData: weightArrays,
                        weightShapes: weightShapes,
                        metadata: {
                            version: '1.0',
                            exportDate: new Date().toISOString(),
                            layers: this.layers,
                            normalizationParams: this.normalizationParams
                        }
                    };
                    
                    // Create download link
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `neuralgenesis_model_${Date.now()}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    this.log('[Export] Model exported successfully');
                    
                } catch (error) {
                    this.log(`[Error] Export failed: ${error.message}`, 'error');
                }
            }
            
            // ============ LOGGING ============
            
            log(message, type = 'info') {
                if (!this.logging && type !== 'error') return;
                
                const terminal = document.getElementById('terminalOutput');
                const logEntry = document.createElement('div');
                
                let color = 'text-white/70';
                if (type === 'error') color = 'text-red-400';
                if (type === 'warning') color = 'text-amber';
                if (type === 'gradient') color = 'text-cyan';
                
                logEntry.className = `${color} animate-fade-in`;
                logEntry.textContent = message;
                
                terminal.appendChild(logEntry);
                terminal.scrollTop = terminal.scrollHeight;
                
                // Keep terminal manageable
                const entries = terminal.querySelectorAll('div');
                if (entries.length > 100) {
                    entries[0].remove();
                }
            }
            
            // ============ EVENT HANDLERS ============
            
            setupEventListeners() {
                // Dataset upload
                document.getElementById('datasetUpload').addEventListener('change', (e) => this.handleDatasetUpload(e));
                
                // Layer management
                document.getElementById('addLayer').addEventListener('click', () => {
                    const type = document.getElementById('layerType').value;
                    this.addLayer(type);
                });
                
                // Training controls
                document.getElementById('trainBtn').addEventListener('click', () => this.train());
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.paused = !this.paused;
                    const icon = this.paused ? 'play' : 'pause';
                    document.querySelector('#pauseBtn i').setAttribute('data-lucide', icon);
                    lucide.createIcons();
                    
                    this.log(this.paused ? '[Training] Paused' : '[Training] Resumed');
                });
                
                // Export
                document.getElementById('exportBtn').addEventListener('click', () => this.exportModel());
                
                // Weight controls
                document.getElementById('randomizeWeights').addEventListener('click', () => this.randomizeWeights());
                
                // Clear dataset
                document.getElementById('clearDataset').addEventListener('click', () => {
                    this.dataset = null;
                    document.getElementById('datasetInfo').classList.add('hidden');
                    document.getElementById('featureSelection').classList.add('hidden');
                    document.getElementById('chatInput').disabled = true;
                    document.getElementById('sendChat').disabled = true;
                    this.log('[Dataset] Dataset cleared');
                });
                
                // Clear terminal
                document.getElementById('clearTerminal').addEventListener('click', () => {
                    document.getElementById('terminalOutput').innerHTML = '';
                });
                
                // Pause logging
                document.getElementById('pauseLogging').addEventListener('click', () => {
                    this.logging = !this.logging;
                    const btn = document.getElementById('pauseLogging');
                    btn.textContent = this.logging ? 'Pause Logging' : 'Resume Logging';
                    this.log(this.logging ? '[System] Logging resumed' : '[System] Logging paused');
                });
                
                // Performance mode
                document.getElementById('performanceToggle').addEventListener('click', () => {
                    this.performanceMode = !this.performanceMode;
                    document.body.classList.toggle('performance-mode', this.performanceMode);
                    const btn = document.getElementById('performanceToggle');
                    btn.innerHTML = this.performanceMode ? 
                        '<i data-lucide="zap-off"></i><span>Normal Mode</span>' :
                        '<i data-lucide="battery"></i><span>Performance Mode</span>';
                    lucide.createIcons();
                    
                    this.log(`[System] ${this.performanceMode ? 'Performance mode enabled' : 'Performance mode disabled'}`);
                });
                
                // Chat inference
                document.getElementById('sendChat').addEventListener('click', () => {
                    const input = document.getElementById('chatInput');
                    const text = input.value.trim();
                    
                    if (text) {
                        const chatOutput = document.getElementById('chatOutput');
                        const userMsg = document.createElement('div');
                        userMsg.textContent = `You: ${text}`;
                        chatOutput.appendChild(userMsg);
                        
                        this.runInference(text).then(result => {
                            if (result) {
                                const botMsg = document.createElement('div');
                                botMsg.className = 'text-cyan';
                                botMsg.textContent = `Model: Confidence ${(result.confidence * 100).toFixed(1)}% (Class ${result.class})`;
                                chatOutput.appendChild(botMsg);
                            }
                        });
                        
                        input.value = '';
                        chatOutput.scrollTop = chatOutput.scrollHeight;
                    }
                });
                
                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('sendChat').click();
                    }
                });
                
                // Mobile modal controls
                document.querySelectorAll('[data-modal]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const modal = btn.getAttribute('data-modal');
                        this.showMobileModal(modal);
                    });
                });
                
                // Window resize handling
                window.addEventListener('resize', () => {
                    this.updateNeuralVisualization();
                    this.updateTrainingCharts();
                });
            }
            
            showMobileModal(modal) {
                // Hide all modals
                document.querySelectorAll('.mobile-modal').forEach(m => m.classList.add('hidden'));
                
                // Show selected modal
                const modalEl = document.getElementById(`mobile${modal.charAt(0).toUpperCase() + modal.slice(1)}Modal`);
                if (modalEl) {
                    modalEl.classList.remove('hidden');
                }
            }
        }
        
        // Initialize the application
        let app;
        
        // Ensure TensorFlow.js is loaded
        if (typeof tf !== 'undefined') {
            document.addEventListener('DOMContentLoaded', () => {
                app = new NeuralGenesis();
                
                // Update TensorFlow version display
                document.getElementById('tfVersion').textContent = `TensorFlow.js v${tf.version.tfjs}`;
                
                // Initial neural visualization
                setTimeout(() => app.updateNeuralVisualization(), 100);
            });
        } else {
            console.error('TensorFlow.js failed to load');
        }
        
        // Expose app globally for inline event handlers
        window.app = app;
    </script>
</body>
</html>
